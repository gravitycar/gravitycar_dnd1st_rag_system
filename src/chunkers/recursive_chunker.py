#!/usr/bin/env python3
"""
Recursive Chunker for D&D Rulebooks

This module implements a hierarchical, heading-based chunker for markdown documents
generated by Docling from PDF conversion. It supports intelligent chunking based on
document structure with extensible special case handlers.

Usage:
    python src/chunkers/recursive_chunker.py <markdown_file> [--output <path>] [--report]

Default Behavior:
    Chunks on level 2 AND level 3 headings (## and ###)
    - Level 2 intro content (before first ###) = separate chunk
    - Each level 3 heading = separate chunk (includes all level 4+ nested content)
    - Level 3 chunks reference their parent level 2 chunk

Special Cases:
    - Spell sections: Chunks on level 5 (spell names), includes level 6 subheadings
    - Notes sections: Single chunk until next heading
    - Random Monster Encounters (DMG Appendix C): Chunks on level 3 AND level 4
    - Magic Items (DMG TREASURE section): Chunks on level 4 (item types) AND level 5 (individual items)
    - Insanity (DMG COMBAT section): Chunks on level 3 AND level 4 (TYPES OF INSANITY table and individual types)
    - Random Treasure Determination (DMG TREASURE section): Chunks on level 3 AND level 4 (treasure tables)
    - Random Generation of Creatures from Lower Planes (DMG Appendix D): Chunks on level 3 AND level 4 (creature attribute tables)
    - A Sample Dungeon (DMG THE CAMPAIGN section): Chunks on level 3 AND level 4 (wandering monsters, monastery cellars, etc.)
    - Pursuit and Evasion of Pursuit (DMG COMBAT section): Chunks on level 3 AND level 4 (underground settings, outdoor settings, etc.)

Examples:
    # Chunk Player's Handbook with default settings
    python src/chunkers/recursive_chunker.py data/markdown/Players_Handbook_(1e).md

    # Chunk with detailed report
    python src/chunkers/recursive_chunker.py data/markdown/Players_Handbook_(1e).md --report

    # Specify output location
    python src/chunkers/recursive_chunker.py data/markdown/DM_Guide.md \\
        --output data/chunks/dm_guide.json
"""

import json
import re
import sys
from abc import ABC, abstractmethod
from collections import deque
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


# ============================================================================
# Data Structures
# ============================================================================

@dataclass
class Heading:
    """Represents a markdown heading with context."""
    level: int              # 1-6
    text: str               # "CLERIC SPELLS"
    line_number: int        # Line in source file
    hierarchy: List[str]    # ["SPELL EXPLANATIONS", "CLERIC SPELLS"]


@dataclass
class Chunk:
    """Represents a content chunk with metadata."""
    uid: str
    book: str
    title: str
    content: str
    metadata: Dict[str, Any]


# ============================================================================
# Special Case Handler System
# ============================================================================

class SpecialCaseHandler(ABC):
    """Abstract base class for special case handlers."""
    
    @abstractmethod
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if this handler applies to current hierarchy."""
        pass
    
    @abstractmethod
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Return which heading level to chunk on."""
        pass
    
    @abstractmethod
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Check if subheadings should be included in chunk."""
        pass


class SpellSectionHandler(SpecialCaseHandler):
    """Handler for spell sections - chunks on level 5 (individual spells)."""
    
    SPELL_PATTERNS = [
        r"SPELL EXPLANATIONS",
        r"(CLERIC|DRUID|MAGIC-USER|ILLUSIONIST) SPELLS",
        r"(First|Second|Third|Fourth|Fifth|Sixth|Seventh|Eighth|Ninth|1st|2nd|3rd|4th|5th|6th|7th|8th|9th) Level Spells",
    ]
    
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if hierarchy represents a spell section."""
        if len(hierarchy) < 3:
            return False
        
        # Check if first element matches SPELL EXPLANATIONS
        if not re.search(self.SPELL_PATTERNS[0], hierarchy[0], re.IGNORECASE):
            return False
        
        # Check if second element matches spell type
        if len(hierarchy) >= 2:
            if not re.search(self.SPELL_PATTERNS[1], hierarchy[1], re.IGNORECASE):
                return False
        
        # Check if third element matches level pattern
        if len(hierarchy) >= 3:
            if not re.search(self.SPELL_PATTERNS[2], hierarchy[2], re.IGNORECASE):
                return False
        
        return True
    
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Chunk on level 5 (individual spells)."""
        return 5
    
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Include level 6 headings within spell chunks."""
        return subheading_level == 6


class NotesRegardingHandler(SpecialCaseHandler):
    """Handler for 'Notes Regarding' sections - chunks as single unit."""
    
    PATTERN = r"Notes Regarding (Cleric|Druid|Magic-User|Illusionist).*Spells:"
    
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if hierarchy represents a notes section."""
        if not hierarchy:
            return False
        # Check the last element of hierarchy
        return bool(re.search(self.PATTERN, hierarchy[-1], re.IGNORECASE))
    
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Chunk at the current level."""
        return len(hierarchy)
    
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Include all subheadings until next peer heading."""
        return True


class RandomMonsterEncountersHandler(SpecialCaseHandler):
    """Handler for Appendix C: Random Monster Encounters - chunks on level 3 and level 4."""
    
    PATTERN = r"APPENDIX C.*RANDOM MONSTER ENCOUNTERS"
    
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if hierarchy represents the Random Monster Encounters section."""
        if not hierarchy:
            return False
        # Check if any element in hierarchy matches APPENDIX C pattern
        # This handles both the level 3 heading itself and its children
        return any(re.search(self.PATTERN, h, re.IGNORECASE) for h in hierarchy)
    
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Chunk on level 3 and level 4 headings."""
        # Return a list-like behavior - we need to check both levels
        # This method is called by should_create_chunk in ChunkBuilder
        # We'll return 3 as primary, but need to modify ChunkBuilder to handle both
        return 3
    
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Include level 5+ headings within chunks."""
        return subheading_level >= 5


class MagicItemsHandler(SpecialCaseHandler):
    """Handler for TREASURE → EXPLANATIONS AND DESCRIPTIONS OF MAGIC ITEMS section.
    
    Chunks on level 4 (item type categories like POTIONS, SCROLLS, RINGS) and 
    level 5 (individual magic items).
    """
    
    # Patterns to match the magic items section hierarchy
    TREASURE_PATTERN = r"^TREASURE$"
    MAGIC_ITEMS_PATTERN = r"EXPLANATIONS AND DESCRIPTIONS OF MAGIC ITEMS"
    
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if hierarchy represents the magic items section."""
        if len(hierarchy) < 2:
            return False
        
        # Must be under TREASURE section
        if not re.search(self.TREASURE_PATTERN, hierarchy[0], re.IGNORECASE):
            return False
        
        # Must be under EXPLANATIONS AND DESCRIPTIONS OF MAGIC ITEMS
        if not any(re.search(self.MAGIC_ITEMS_PATTERN, h, re.IGNORECASE) for h in hierarchy):
            return False
        
        return True
    
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Chunk on level 4 and level 5 headings."""
        # Return 4 as primary, but ChunkBuilder will handle both 4 and 5
        return 4
    
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Include level 6+ headings within individual magic item chunks."""
        return subheading_level >= 6


class InsanityHandler(SpecialCaseHandler):
    """Handler for COMBAT → INSANITY section.
    
    Chunks on level 3 (INSANITY intro) and level 4 (TYPES OF INSANITY table and 
    individual insanity types like Dipsomania, Kleptomania, etc.).
    """
    
    INSANITY_PATTERN = r"^INSANITY$"
    
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if hierarchy represents the INSANITY section."""
        if not hierarchy:
            return False
        
        # Check if INSANITY is in the hierarchy
        return any(re.search(self.INSANITY_PATTERN, h, re.IGNORECASE) for h in hierarchy)
    
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Chunk on level 3 and level 4 headings."""
        # Return 3 as primary, but ChunkBuilder will handle both 3 and 4
        return 3
    
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Include level 5+ headings within chunks."""
        return subheading_level >= 5


class RandomTreasureDeterminationHandler(SpecialCaseHandler):
    """Handler for TREASURE → RANDOM TREASURE DETERMINATION section.
    
    Chunks on level 3 (section intro) and level 4 (MAP OR MAGIC DETERMINATION,
    MONETARY TREASURE, MAGIC TREASURE, COMBINED HOARD, etc.).
    """
    
    RANDOM_TREASURE_PATTERN = r"RANDOM TREASURE DETERMINATION"
    
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if hierarchy represents the RANDOM TREASURE DETERMINATION section."""
        if not hierarchy:
            return False
        
        # Check if RANDOM TREASURE DETERMINATION is in the hierarchy
        return any(re.search(self.RANDOM_TREASURE_PATTERN, h, re.IGNORECASE) for h in hierarchy)
    
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Chunk on level 3 and level 4 headings."""
        # Return 3 as primary, but ChunkBuilder will handle both 3 and 4
        return 3
    
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Include level 5+ headings within chunks."""
        return subheading_level >= 5


class LowerPlanesCreaturesHandler(SpecialCaseHandler):
    """Handler for APPENDICES → APPENDIX D: RANDOM GENERATION OF CREATURES FROM THE LOWER PLANES.
    
    Chunks on level 3 (section intro) and level 4 (Appearance Table, BODY ATTRIBUTES,
    ATTACK TABLE, SPECIAL ATTACKS, etc.).
    """
    
    LOWER_PLANES_PATTERN = r"RANDOM GENERATION OF CREATURES FROM THE LOWER PLANES"
    
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if hierarchy represents the RANDOM GENERATION OF CREATURES FROM THE LOWER PLANES section."""
        if not hierarchy:
            return False
        
        # Check if pattern is in the hierarchy
        return any(re.search(self.LOWER_PLANES_PATTERN, h, re.IGNORECASE) for h in hierarchy)
    
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Chunk on level 3 and level 4 headings."""
        # Return 3 as primary, but ChunkBuilder will handle both 3 and 4
        return 3
    
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Include level 5+ headings within chunks."""
        return subheading_level >= 5


class SampleDungeonHandler(SpecialCaseHandler):
    """Handler for THE CAMPAIGN → A SAMPLE DUNGEON section.
    
    Chunks on level 3 (section intro) and level 4 (WANDERING MONSTERS, 
    MONASTERY CELLARS & SECRET CRYPTS, etc.).
    """
    
    SAMPLE_DUNGEON_PATTERN = r"^A SAMPLE DUNGEON$"
    
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if hierarchy represents the A SAMPLE DUNGEON section."""
        if not hierarchy:
            return False
        
        # Check if pattern is in the hierarchy
        return any(re.search(self.SAMPLE_DUNGEON_PATTERN, h, re.IGNORECASE) for h in hierarchy)
    
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Chunk on level 3 and level 4 headings."""
        # Return 3 as primary, but ChunkBuilder will handle both 3 and 4
        return 3
    
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Include level 5+ headings within chunks."""
        return subheading_level >= 5


class PursuitEvasionHandler(SpecialCaseHandler):
    """Handler for COMBAT → PURSUIT AND EVASION OF PURSUIT section.
    
    Chunks on level 3 (section intro) and level 4 (underground settings, 
    outdoor settings, etc.).
    """
    
    PURSUIT_EVASION_PATTERN = r"^PURSUIT AND EVASION OF PURSUIT$"
    
    def matches(self, hierarchy: List[str]) -> bool:
        """Check if hierarchy represents the PURSUIT AND EVASION OF PURSUIT section."""
        if not hierarchy:
            return False
        
        # Check if pattern is in the hierarchy
        return any(re.search(self.PURSUIT_EVASION_PATTERN, h, re.IGNORECASE) for h in hierarchy)
    
    def get_chunk_level(self, hierarchy: List[str]) -> int:
        """Chunk on level 3 and level 4 headings."""
        # Return 3 as primary, but ChunkBuilder will handle both 3 and 4
        return 3
    
    def should_include_subheadings(self, subheading_level: int) -> bool:
        """Include level 5+ headings within chunks."""
        return subheading_level >= 5


class SpecialCaseRegistry:
    """Registry for special case handlers."""
    
    def __init__(self):
        self.handlers: List[SpecialCaseHandler] = [
            SpellSectionHandler(),
            NotesRegardingHandler(),
            RandomMonsterEncountersHandler(),
            MagicItemsHandler(),
            InsanityHandler(),
            RandomTreasureDeterminationHandler(),
            LowerPlanesCreaturesHandler(),
            SampleDungeonHandler(),
            PursuitEvasionHandler(),
        ]
    
    def get_handler(self, hierarchy: List[str]) -> Optional[SpecialCaseHandler]:
        """Get handler for hierarchy, or None for default behavior."""
        for handler in self.handlers:
            if handler.matches(hierarchy):
                return handler
        return None


# ============================================================================
# Core Components
# ============================================================================

class HeadingParser:
    """Parses markdown headings and maintains hierarchy stack."""
    
    HEADING_PATTERN = re.compile(r'^(#{1,6})\s+(.+)$')
    
    def __init__(self):
        self.hierarchy_stack: deque = deque()
        self.current_line = 0
    
    def parse_heading(self, line: str, line_number: int) -> Optional[Heading]:
        """Parse a line as a heading, return None if not a heading."""
        match = self.HEADING_PATTERN.match(line.strip())
        if not match:
            return None
        
        level = len(match.group(1))
        text = match.group(2).strip()
        
        # Update hierarchy stack
        self._update_hierarchy(level, text)
        
        # Build current hierarchy
        hierarchy = list(self.hierarchy_stack)
        
        return Heading(
            level=level,
            text=text,
            line_number=line_number,
            hierarchy=hierarchy
        )
    
    def _update_hierarchy(self, level: int, text: str):
        """Update hierarchy stack when new heading encountered.
        
        The stack depth after adding should equal level - 1:
        - Level 2 heading: Final depth = 1 ['SECTION']
        - Level 3 heading: Final depth = 2 ['SECTION', 'SUBSECTION']
        - Level 4 heading: Final depth = 3 ['SECTION', 'SUBSECTION', 'SUBSUBSECTION']
        
        So before appending, we need depth = level - 2.
        Pop while len(stack) >= level - 1
        """
        # Pop items to make room for this level
        while len(self.hierarchy_stack) >= level - 1:
            self.hierarchy_stack.pop()
        
        # Append new heading
        self.hierarchy_stack.append(text)
    
    def get_current_hierarchy(self) -> List[str]:
        """Get current hierarchy as list."""
        return list(self.hierarchy_stack)


class ChunkBuilder:
    """Builds chunks from markdown content with metadata."""
    
    # Sections to skip entirely (heading text patterns to match)
    SKIP_SECTIONS = [
        r"APPENDIX E.*ALPHABETICAL RECAPITULATION OF MONSTERS",
    ]
    
    def __init__(self, book_name: str, registry: SpecialCaseRegistry):
        self.book_name = book_name
        self.registry = registry
        self.chunks: List[Chunk] = []
        self.current_chunk_content: List[str] = []
        self.current_chunk_start_line: int = 0
        self.current_chunk_heading: Optional[Heading] = None
        self.parent_chunk_uid: Optional[str] = None
        self.chunk_counter: Dict[str, int] = {}
        self.in_skip_section: bool = False
        self.skip_section_level: Optional[int] = None
    
    def should_skip_section(self, heading: Heading) -> bool:
        """Check if this heading starts a section that should be skipped entirely."""
        heading_text = heading.text
        for pattern in self.SKIP_SECTIONS:
            if re.search(pattern, heading_text, re.IGNORECASE):
                return True
        return False
    
    def should_create_chunk(self, heading: Heading) -> bool:
        """Determine if we should create a chunk at this heading."""
        # Check for special case handler
        handler = self.registry.get_handler(heading.hierarchy)
        
        if handler:
            # Special case: RandomMonsterEncountersHandler chunks on both level 3 and 4
            if isinstance(handler, RandomMonsterEncountersHandler):
                return heading.level in [3, 4]
            # Special case: MagicItemsHandler chunks on both level 4 and 5
            if isinstance(handler, MagicItemsHandler):
                return heading.level in [4, 5]
            # Special case: InsanityHandler chunks on both level 3 and 4
            if isinstance(handler, InsanityHandler):
                return heading.level in [3, 4]
            # Special case: RandomTreasureDeterminationHandler chunks on both level 3 and 4
            if isinstance(handler, RandomTreasureDeterminationHandler):
                return heading.level in [3, 4]
            # Special case: LowerPlanesCreaturesHandler chunks on both level 3 and 4
            if isinstance(handler, LowerPlanesCreaturesHandler):
                return heading.level in [3, 4]
            # Special case: SampleDungeonHandler chunks on both level 3 and 4
            if isinstance(handler, SampleDungeonHandler):
                return heading.level in [3, 4]
            # Special case: PursuitEvasionHandler chunks on both level 3 and 4
            if isinstance(handler, PursuitEvasionHandler):
                return heading.level in [3, 4]
            # Use handler's chunk level for other handlers
            target_level = handler.get_chunk_level(heading.hierarchy)
            return heading.level == target_level
        
        # Default: chunk on level 2 and level 3
        return heading.level in [2, 3]
    
    def start_chunk(self, heading: Heading):
        """Start a new chunk at this heading."""
        # Finalize previous chunk if exists
        if self.current_chunk_heading:
            self._finalize_current_chunk(heading.line_number - 1)
        
        # Start new chunk
        self.current_chunk_heading = heading
        self.current_chunk_content = []
        self.current_chunk_start_line = heading.line_number
        
        # Update parent chunk UID for level 3, 4, and 5 chunks
        if heading.level == 3 and len(heading.hierarchy) >= 2:
            # Parent is level 2
            parent_hierarchy = heading.hierarchy[:-1]
            self.parent_chunk_uid = self._generate_uid(parent_hierarchy, base_only=True)
        elif heading.level == 4 and len(heading.hierarchy) >= 2:
            # Parent is level 3
            parent_hierarchy = heading.hierarchy[:-1]
            self.parent_chunk_uid = self._generate_uid(parent_hierarchy, base_only=True)
        elif heading.level == 5 and len(heading.hierarchy) >= 2:
            # Parent is level 4 (for magic items sections)
            parent_hierarchy = heading.hierarchy[:-1]
            self.parent_chunk_uid = self._generate_uid(parent_hierarchy, base_only=True)
        elif heading.level == 2:
            self.parent_chunk_uid = None
    
    def add_content_line(self, line: str):
        """Add a line to current chunk."""
        self.current_chunk_content.append(line)
    
    def finalize(self, total_lines: int):
        """Finalize the last chunk."""
        if self.current_chunk_heading:
            self._finalize_current_chunk(total_lines)
    
    def _finalize_current_chunk(self, end_line: int):
        """Create chunk from accumulated content."""
        if not self.current_chunk_heading:
            return
        
        content = '\n'.join(self.current_chunk_content).strip()
        if not content:
            return
        
        # Generate UID
        uid = self._generate_uid(self.current_chunk_heading.hierarchy)
        
        # Determine chunk type
        handler = self.registry.get_handler(self.current_chunk_heading.hierarchy)
        if handler:
            if isinstance(handler, SpellSectionHandler):
                chunk_type = "spell"
            elif isinstance(handler, NotesRegardingHandler):
                chunk_type = "notes"
            elif isinstance(handler, RandomMonsterEncountersHandler):
                chunk_type = "encounter"
            elif isinstance(handler, MagicItemsHandler):
                chunk_type = "magic_item"
            elif isinstance(handler, InsanityHandler):
                chunk_type = "insanity"
            elif isinstance(handler, RandomTreasureDeterminationHandler):
                chunk_type = "treasure"
            elif isinstance(handler, LowerPlanesCreaturesHandler):
                chunk_type = "lower_planes"
            elif isinstance(handler, SampleDungeonHandler):
                chunk_type = "sample_dungeon"
            elif isinstance(handler, PursuitEvasionHandler):
                chunk_type = "pursuit_evasion"
            else:
                chunk_type = "special"
            special_handler_name = handler.__class__.__name__
        else:
            chunk_type = "default"
            special_handler_name = None
        
        # Create metadata
        metadata = {
            "hierarchy": self.current_chunk_heading.hierarchy,
            "parent_heading": self.current_chunk_heading.hierarchy[-2] if len(self.current_chunk_heading.hierarchy) > 1 else None,
            "parent_chunk_uid": self.parent_chunk_uid,
            "start_line": self.current_chunk_start_line,
            "end_line": end_line,
            "char_count": len(content),
            "chunk_type": chunk_type,  # Our internal type
            "type": chunk_type,  # For embedder compatibility
            "chunk_level": self.current_chunk_heading.level,
        }
        
        if special_handler_name:
            metadata["special_handler"] = special_handler_name
        
        # Create chunk
        chunk = Chunk(
            uid=uid,
            book=self.book_name,
            title=self.current_chunk_heading.text,
            content=content,
            metadata=metadata
        )
        
        self.chunks.append(chunk)
    
    def _generate_uid(self, hierarchy: List[str], base_only: bool = False) -> str:
        """Generate unique ID from hierarchy."""
        # Clean hierarchy elements for UID
        clean_hierarchy = [
            re.sub(r'[^a-zA-Z0-9_]', '_', elem).strip('_')
            for elem in hierarchy
        ]
        
        # Create base UID
        base_uid = f"{self.book_name}_{'_'.join(clean_hierarchy)}"
        
        if base_only:
            return base_uid
        
        # Add counter for uniqueness
        if base_uid not in self.chunk_counter:
            self.chunk_counter[base_uid] = 0
        
        self.chunk_counter[base_uid] += 1
        
        return f"{base_uid}_{self.chunk_counter[base_uid]}"
    
    def get_chunks(self) -> List[Chunk]:
        """Get all created chunks."""
        return self.chunks


class SplitManager:
    """Manages splitting of oversized chunks."""
    
    def __init__(self, max_chunk_size: int = 2000):
        self.max_chunk_size = max_chunk_size
    
    def compress_table_line(self, line: str) -> str:
        """Strip whitespace from table cells while preserving structure."""
        if '|' not in line:
            return line
        cells = line.split('|')
        compressed = '|'.join(cell.strip() for cell in cells)
        return compressed
    
    def compress_tables_in_content(self, content: str) -> str:
        """Compress all tables in content."""
        lines = content.split('\n')
        compressed_lines = []
        
        for line in lines:
            if '|' in line:
                compressed_lines.append(self.compress_table_line(line))
            else:
                compressed_lines.append(line)
        
        return '\n'.join(compressed_lines)
    
    def is_in_table(self, content: str, position: int) -> bool:
        """Check if position is within a table."""
        # Get lines before position
        lines_before = content[:position].split('\n')
        
        # Check last few lines for pipe characters
        for line in reversed(lines_before[-10:]):
            if '|' in line:
                return True
            if line.strip() == '':
                return False
        
        return False
    
    def find_table_end(self, content: str, start_pos: int) -> int:
        """Find end of table starting from position.
        
        CRITICAL: Tables are NEVER split, regardless of size. This method always
        returns the end of the complete table, even if it results in a chunk
        exceeding the normal size limits. This preserves table integrity for
        better semantic understanding and prevents broken table structures.
        """
        remaining = content[start_pos:]
        lines = remaining.split('\n')
        
        for i, line in enumerate(lines):
            if line.strip() == '' or '|' not in line:
                # Found end of table
                return start_pos + sum(len(l) + 1 for l in lines[:i])
        
        # Table extends to end of content
        return len(content)
    
    def split_chunk(self, chunk: Chunk) -> List[Chunk]:
        """Split chunk if it exceeds max size."""
        # First, compress tables
        compressed_content = self.compress_tables_in_content(chunk.content)
        
        # Check if compression was enough
        if len(compressed_content) <= self.max_chunk_size:
            # Update chunk with compressed content
            chunk.content = compressed_content
            chunk.metadata["char_count"] = len(compressed_content)
            return [chunk]
        
        # Need to split - use compressed content
        content = compressed_content
        
        if len(content) <= self.max_chunk_size:
            return [chunk]
        
        split_chunks = []
        current_pos = 0
        chunk_num = 1
        base_uid = chunk.uid
        
        while current_pos < len(content):
            # Find paragraph boundary after max_chunk_size
            target_pos = current_pos + self.max_chunk_size
            hard_limit = current_pos + (self.max_chunk_size * 1.5)  # Hard limit at 3000 chars
            
            if target_pos >= len(content):
                # Last chunk
                split_pos = len(content)
            else:
                # Strategy: Try to find best split point, but never exceed hard_limit (unless table)
                best_split = None
                
                # 1. Try to find paragraph boundary (\n\n) after target, within hard limit
                para_split = content.find("\n\n", target_pos, int(hard_limit))
                if para_split != -1:
                    best_split = para_split
                
                # 2. If no paragraph boundary, try single newline (\n) after target, within hard limit
                if best_split is None:
                    newline_split = content.find("\n", target_pos, int(hard_limit))
                    if newline_split != -1:
                        best_split = newline_split
                
                # 3. If still nothing forward, search backwards from target for paragraph boundary
                if best_split is None:
                    para_split_back = content.rfind("\n\n", current_pos, target_pos)
                    if para_split_back != -1:
                        best_split = para_split_back
                
                # 4. If still nothing, search backwards for single newline
                if best_split is None:
                    newline_split_back = content.rfind("\n", current_pos, target_pos)
                    if newline_split_back != -1:
                        best_split = newline_split_back
                
                # 5. If absolutely no newlines found, enforce hard limit
                if best_split is None:
                    best_split = int(hard_limit) if hard_limit < len(content) else len(content)
                
                split_pos = best_split
                
                # CRITICAL: Check if we're in a table - NEVER split tables regardless of size
                if self.is_in_table(content, split_pos):
                    table_end = self.find_table_end(content, split_pos)
                    # Always use table_end - tables are never split, no matter the size
                    split_pos = table_end
            
            # Extract chunk content
            chunk_content = content[current_pos:split_pos].strip()
            
            if chunk_content:
                # Create sub-chunk metadata
                sub_metadata = chunk.metadata.copy()
                sub_metadata["uid"] = f"{base_uid}_part{chunk_num}"
                sub_metadata["original_chunk_uid"] = base_uid
                sub_metadata["chunk_part"] = chunk_num
                sub_metadata["chunk_type"] = "split"
                sub_metadata["char_count"] = len(chunk_content)
                
                # Create sub-chunk
                sub_chunk = Chunk(
                    uid=sub_metadata["uid"],
                    book=chunk.book,
                    title=chunk.title,
                    content=chunk_content,
                    metadata=sub_metadata
                )
                
                split_chunks.append(sub_chunk)
                chunk_num += 1
            
            # Calculate how many characters to skip based on what we found
            # Skip \n\n if we split on paragraph boundary, \n if single newline, or nothing if end of content
            if split_pos < len(content):
                if split_pos + 1 < len(content) and content[split_pos:split_pos+2] == "\n\n":
                    current_pos = split_pos + 2  # Skip the \n\n
                elif content[split_pos:split_pos+1] == "\n":
                    current_pos = split_pos + 1  # Skip the \n
                else:
                    current_pos = split_pos
            else:
                current_pos = split_pos
        
        # Add sibling references
        if len(split_chunks) > 1:
            all_uids = [c.uid for c in split_chunks]
            for sub_chunk in split_chunks:
                sub_chunk.metadata["sibling_chunks"] = [
                    uid for uid in all_uids if uid != sub_chunk.uid
                ]
                sub_chunk.metadata["total_parts"] = len(split_chunks)
        
        return split_chunks if split_chunks else [chunk]


class ReportGenerator:
    """Generates chunking statistics and reports."""
    
    def __init__(self):
        self.stats = {
            "total_chunks": 0,
            "chunk_types": {},
            "oversized_chunks": [],
            "size_distribution": {
                "0-500": 0,
                "501-1000": 0,
                "1001-1500": 0,
                "1501-2000": 0,
                "2001+": 0,
            }
        }
    
    def collect_stats(self, chunks: List[Chunk], threshold: int = 2000):
        """Collect statistics from chunks."""
        self.stats["total_chunks"] = len(chunks)
        
        for chunk in chunks:
            # Count by type
            chunk_type = chunk.metadata.get("chunk_type", "unknown")
            self.stats["chunk_types"][chunk_type] = self.stats["chunk_types"].get(chunk_type, 0) + 1
            
            # Size distribution
            size = chunk.metadata["char_count"]
            if size <= 500:
                self.stats["size_distribution"]["0-500"] += 1
            elif size <= 1000:
                self.stats["size_distribution"]["501-1000"] += 1
            elif size <= 1500:
                self.stats["size_distribution"]["1001-1500"] += 1
            elif size <= 2000:
                self.stats["size_distribution"]["1501-2000"] += 1
            else:
                self.stats["size_distribution"]["2001+"] += 1
            
            # Flag oversized chunks
            if size > threshold:
                self.stats["oversized_chunks"].append({
                    "uid": chunk.uid,
                    "title": chunk.title,
                    "hierarchy": chunk.metadata["hierarchy"],
                    "start_line": chunk.metadata["start_line"],
                    "char_count": size,
                    "chunk_type": chunk_type,
                })
        
        # Sort oversized chunks by size (largest first)
        self.stats["oversized_chunks"].sort(key=lambda x: x["char_count"], reverse=True)
    
    def print_report(self):
        """Print formatted report."""
        print("\n" + "=" * 70)
        print("CHUNKING REPORT")
        print("=" * 70)
        
        print(f"\nTotal Chunks: {self.stats['total_chunks']}")
        
        print("\nChunk Types:")
        for chunk_type, count in sorted(self.stats['chunk_types'].items()):
            print(f"  {chunk_type:15} {count:5} chunks")
        
        print("\nSize Distribution:")
        for size_range, count in self.stats['size_distribution'].items():
            percentage = (count / self.stats['total_chunks'] * 100) if self.stats['total_chunks'] > 0 else 0
            print(f"  {size_range:15} {count:5} chunks ({percentage:5.1f}%)")
        
        if self.stats["oversized_chunks"]:
            print(f"\nOversized Chunks (>{2000} characters): {len(self.stats['oversized_chunks'])}")
            for chunk_info in self.stats["oversized_chunks"][:10]:  # Show first 10
                print(f"  - {chunk_info['title'][:50]:50} | Line {chunk_info['start_line']:5} | {chunk_info['char_count']:5} chars")
            
            if len(self.stats["oversized_chunks"]) > 10:
                print(f"  ... and {len(self.stats['oversized_chunks']) - 10} more")
        
        print("\n" + "=" * 70 + "\n")


# ============================================================================
# Main Chunker Class
# ============================================================================

class RecursiveChunker:
    """Main chunker class orchestrating the chunking process."""
    
    def __init__(self, markdown_file: str, output_file: Optional[str] = None, 
                 max_chunk_size: int = 2000, report: bool = False):
        self.markdown_file = Path(markdown_file)
        self.output_file = Path(output_file) if output_file else self._default_output_path()
        self.max_chunk_size = max_chunk_size
        self.report = report
        
        # Extract book name from filename
        self.book_name = self.markdown_file.stem
        
        # Initialize components
        self.parser = HeadingParser()
        self.registry = SpecialCaseRegistry()
        self.builder = ChunkBuilder(self.book_name, self.registry)
        self.splitter = SplitManager(max_chunk_size)
        self.reporter = ReportGenerator()
    
    def _default_output_path(self) -> Path:
        """Generate default output path."""
        output_dir = Path("data/chunks")
        output_dir.mkdir(parents=True, exist_ok=True)
        return output_dir / f"chunks_{self.markdown_file.name.replace('.md', '.json')}"
    
    def process(self) -> List[Chunk]:
        """Process markdown file and generate chunks."""
        print(f"Processing: {self.markdown_file}")
        print(f"Output: {self.output_file}")
        
        # Read and process file
        with open(self.markdown_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        total_lines = len(lines)
        in_chunk = False
        
        for line_num, line in enumerate(lines, start=1):
            # Try to parse as heading
            heading = self.parser.parse_heading(line, line_num)
            
            if heading:
                # Check if we should skip this section entirely
                if self.builder.should_skip_section(heading):
                    # Finalize any current chunk before skipping
                    if in_chunk:
                        self.builder.finalize(line_num - 1)
                        in_chunk = False
                    # Start skipping this section
                    self.builder.in_skip_section = True
                    self.builder.skip_section_level = heading.level
                    continue
                
                # Check if we're exiting a skip section (peer or parent level heading)
                if self.builder.in_skip_section:
                    if heading.level <= self.builder.skip_section_level:
                        # Exiting skip section
                        self.builder.in_skip_section = False
                        self.builder.skip_section_level = None
                        # Fall through to process this heading normally
                    else:
                        # Still in skip section, ignore this heading
                        continue
                
                # Check if we should create a chunk here
                if self.builder.should_create_chunk(heading):
                    self.builder.start_chunk(heading)
                    in_chunk = True
                    # Add the heading line itself
                    self.builder.add_content_line(line.rstrip())
                    continue
                elif in_chunk:
                    # We're in a chunk, add heading as content
                    self.builder.add_content_line(line.rstrip())
                    continue
            
            # Skip content if we're in a skip section
            if self.builder.in_skip_section:
                continue
            
            # Add line to current chunk if we're in one
            if in_chunk:
                self.builder.add_content_line(line.rstrip())
        
        # Finalize last chunk
        self.builder.finalize(total_lines)
        
        # Get chunks
        chunks = self.builder.get_chunks()
        print(f"Initial chunks created: {len(chunks)}")
        
        # Split oversized chunks
        final_chunks = []
        for chunk in chunks:
            split_result = self.splitter.split_chunk(chunk)
            final_chunks.extend(split_result)
        
        print(f"Final chunks after splitting: {len(final_chunks)}")
        
        # Generate report if requested
        if self.report:
            self.reporter.collect_stats(final_chunks, self.max_chunk_size)
            self.reporter.print_report()
        
        # Write output
        self._write_output(final_chunks)
        
        return final_chunks
    
    def _write_output(self, chunks: List[Chunk]):
        """Write chunks to JSON file."""
        output_data = []
        
        for chunk in chunks:
            output_data.append({
                "uid": chunk.uid,
                "book": chunk.book,
                "title": chunk.title,
                "content": chunk.content,
                "metadata": chunk.metadata
            })
        
        with open(self.output_file, 'w', encoding='utf-8') as f:
            json.dump(output_data, f, indent=2, ensure_ascii=False)
        
        print(f"✓ Wrote {len(chunks)} chunks to {self.output_file}")


# ============================================================================
# CLI Interface
# ============================================================================

def main():
    """Main entry point for CLI."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Recursive Chunker for D&D Rulebooks",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    parser.add_argument(
        "markdown_file",
        help="Path to markdown file to chunk"
    )
    
    parser.add_argument(
        "--output",
        help="Output JSON file path (default: data/chunks/chunks_<filename>.json)"
    )
    
    parser.add_argument(
        "--max-chunk-size",
        type=int,
        default=2000,
        help="Maximum chunk size in characters (default: 2000)"
    )
    
    parser.add_argument(
        "--report",
        action="store_true",
        help="Print detailed chunking report"
    )
    
    args = parser.parse_args()
    
    # Validate input file
    if not Path(args.markdown_file).exists():
        print(f"Error: File not found: {args.markdown_file}")
        sys.exit(1)
    
    # Create chunker and process
    chunker = RecursiveChunker(
        markdown_file=args.markdown_file,
        output_file=args.output,
        max_chunk_size=args.max_chunk_size,
        report=args.report
    )
    
    try:
        chunker.process()
        print("\n✓ Chunking complete!")
    except Exception as e:
        print(f"\n✗ Error during chunking: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
